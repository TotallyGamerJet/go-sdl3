package main

import (
	_ "embed"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
)

const (
	genComment = "// Code generated by cmd/ffi2go. DO NOT EDIT.\n"
)

var (
	//go:embed ffi.json
	ffi string

	// Note: can be found at https://wiki.libsdl.org/SDL3/QuickReference
	//go:embed ref.h
	apiRefCode string
)

type FFIEntry struct {
	Name         string      `json:"name"`
	Ns           int         `json:"ns"`
	Tag          string      `json:"tag"`
	Type         *FFIEntry   `json:"type"`
	Value        int         `json:"value"`
	Size         int         `json:"size"`
	Fields       []*FFIEntry `json:"fields"`
	StorageClass string      `json:"storage-class"`
	Variadic     bool        `json:"variadic"`
	Inline       bool        `json:"inline"`
	ReturnType   *FFIEntry   `json:"return-type"`
	Parameters   []*FFIEntry `json:"parameters"`
	BitOffset    int         `json:"bit-offset"`
	BitSize      int         `json:"bit-size"`
	BitAlignment int         `json:"bit-alignment"`
	ID           int         `json:"id"`
	Location     string      `json:"location"`

	symbolSDLPrefix bool
}

var (
	typesConversions = map[string]string{
		"_Bool":          "bool", // TODO: SDLBool
		"int":            "int",
		"Sint8":          "int8",
		"Sint16":         "int16",
		"Sint32":         "int32",
		"Sint64":         "int64",
		"Uint8":          "uint8",
		"Uint16":         "uint16",
		"Uint32":         "uint32",
		"Uint64":         "uint64",
		"long":           "int64",
		"float":          "float32",
		"double":         "float64",
		"unsigned-short": "uint16",
		"unsigned-int":   "uint",
		"unsigned-long":  "ulong",
		"long-long":      "int64", // TODO: sure?
		"ulong":          "uint64",
		"size_t":         "uintptr",
		"wchar_t":        "byte",
		"intptr_t":       "int64",
		"char":           "char", // Note: this allows replacing char* with string
		"unsigned-char":  "byte",
		"void":           "void",
		//"pointer":          "uintptr",
		"function-pointer": "uintptr",
	}
	ignoredHeaders = map[string]struct{}{
		"SDL_oldnames.h":  {},
		"SDL_bits.h":      {},
		"SDL_intrin.h":    {},
		"SDL_main_impl.h": {},
		"SDL_assert.h":    {},
		"SDL_stdinc.h":    {},
		"SDL_endian.h":    {},
	}
	ignoredTypes = map[string]struct{}{
		"GamepadBinding": {},
		"GUID":           {},
	}
	ignoredFunctions = map[string]struct{}{
		"SDL_SetLinuxThreadPriority":          {}, // linux
		"SDL_SetLinuxThreadPriorityAndPolicy": {}, // linux
		"SDL_SetGPUBlendConstants":            {}, // Because of a struct arg
	}
	allowlistedFunctions = map[string]struct{}{
		"SDL_free": {},
	}
	sdlFreeFunctions = map[string]struct{}{
		"SDL_GetDisplays":                    {},
		"SDL_GetFullscreenDisplayModes":      {},
		"SDL_GetWindowICCProfile":            {},
		"SDL_GetWindows":                     {},
		"SDL_GetKeyboards":                   {},
		"SDL_GetMice":                        {},
		"SDL_GetTouchDevices":                {},
		"SDL_GetTouchFingers":                {},
		"SDL_GetGamepads":                    {},
		"SDL_GetGamepadMappings":             {},
		"SDL_GetGamepadMappingForGUID":       {},
		"SDL_GetGamepadMapping":              {},
		"SDL_GetGamepadMappingForID":         {},
		"SDL_GetGamepadBindings":             {},
		"SDL_GetJoysticks":                   {},
		"SDL_GetHaptics":                     {},
		"SDL_GetAudioPlaybackDevices":        {},
		"SDL_GetAudioRecordingDevices":       {},
		"SDL_GetAudioDeviceChannelMap":       {},
		"SDL_GetAudioStreamInputChannelMap":  {},
		"SDL_GetAudioStreamOutputChannelMap": {},
		"SDL_GetPrefPath":                    {},
		"SDL_GlobDirectory":                  {},
		"SDL_GetCurrentDirectory":            {},
		"SDL_LoadFile_IO":                    {},
		"SDL_LoadFile":                       {},
		"SDL_GlobStorageDirectory":           {},
		"SDL_GetSurfaceImages":               {},
		"SDL_GetCameras":                     {},
		"SDL_GetCameraSupportedFormats":      {},
		"SDL_GetClipboardText":               {},
		"SDL_GetPrimarySelectionText":        {},
		"SDL_GetClipboardData":               {},
		"SDL_GetClipboardMimeTypes":          {},
		"SDL_GetSensors":                     {},
		"SDL_GetPreferredLocales":            {},
	}
)

func sanitizeVarName(s string) string {
	var b strings.Builder
	nextCap := true
	for _, r := range s {
		if nextCap && r >= 'a' && r <= 'z' {
			r -= 32
		}
		nextCap = false
		if r == '_' {
			nextCap = true
		} else {
			b.WriteRune(r)
		}
	}

	return b.String()
}

func sanitizeArgName(s string) string {
	switch {
	case s == "func":
		return "function"
	case s == "type":
		return "typ"
	default:
		return s
	}
}

func convType(s string) string {
	s = strings.ReplaceAll(s, ":", "")
	if ret, ok := typesConversions[s]; ok {
		return ret
	}
	return s
}

func postConvertType(s string) string {
	switch s {
	case "*char":
		return "string"
	case "*void":
		return "uintptr"
	default:
		return s
	}
}

func extractType(e *FFIEntry) string {
	var typ string
	switch {
	case e.Tag == ":array":
		typ = fmt.Sprintf("[%d]", e.Size) + extractType(e.Type)
	case e.Tag == ":function-pointer":
		typ = "uintptr"
	case e.Tag == ":pointer":
		typ = "*" + extractType(e.Type)
	case e.Tag == ":struct", e.Tag == "struct":
		typ = e.Name
	default:
		typ = convType(e.Tag)
	}

	return postConvertType(typ)
}

func trimSDLPrefix(e *FFIEntry) {
	e.Tag = strings.TrimPrefix(e.Tag, "SDL_")
	e.Name = strings.TrimPrefix(e.Name, "SDL_")
	if e.Type != nil {
		trimSDLPrefix(e.Type)
	}
	if e.ReturnType != nil {
		trimSDLPrefix(e.ReturnType)
	}
	for _, ee := range e.Fields {
		trimSDLPrefix(ee)
	}
	for _, ee := range e.Parameters {
		trimSDLPrefix(ee)
	}
}

type refFunc struct {
	Name        string
	Description string
}

var (
	whitelistedTypePrefixes = map[string]struct{}{
		"SDL_": {},
		"Vk":   {},
		"X":    {},
	}
	baseTypes = map[string]struct{}{
		"SDL_Event": {},
	}
	uniqueTypes        = map[string]struct{}{}
	uniqueAPIFunctions = map[string]refFunc{}
)

func AllTypesFromAPIRef() {
	for _, l := range strings.Split(apiRefCode, "\n") {
		l = strings.TrimSpace(l)
		l = strings.ReplaceAll(l, "const ", "")
		l = strings.ReplaceAll(l, " * ", "* ")
		l = strings.ReplaceAll(l, " ** ", "** ")
		l = strings.ReplaceAll(l, "* * ", "** ")
		switch {
		case strings.HasPrefix(l, "//"):
			continue
		case strings.HasPrefix(l, "#"):
			continue
		case l == "":
			continue
		default:
			idx := strings.Index(l, "//")
			comment := ""
			if idx != -1 {
				comment = strings.TrimSpace(l[idx+2:])
				comment = strings.TrimSuffix(comment, "\n")
				l = l[:idx]
			}
			// Parse function prototype
			nameIdx := strings.Index(l[1:], "SDL_")
			// Function name
			name := l[nameIdx+1 : strings.Index(l, "(")]
			// Function comment
			comment = name + " => " + comment
			uniqueAPIFunctions[name] = refFunc{
				Name:        name,
				Description: comment,
			}
			// Return type
			typ := strings.TrimSpace(l[:nameIdx])
			typ = strings.ReplaceAll(typ, "*", "")
			uniqueTypes[typ] = struct{}{}
			// Argument types
			args := l[strings.Index(l, "(")+1 : strings.Index(l, ")")]
			argsParts := strings.Split(args, ", ")
			for _, at := range argsParts {
				argParts := strings.Split(at, " ")
				typ = strings.TrimSpace(strings.Join(argParts[:len(argParts)-1], " "))
				typ = strings.ReplaceAll(typ, "*", "")
				typ = strings.ReplaceAll(typ, "struct ", "")
				uniqueTypes[typ] = struct{}{}
			}
		}
	}
	for tp := range uniqueTypes {
		var found bool
		for prefix := range whitelistedTypePrefixes {
			if strings.HasPrefix(tp, prefix) {
				found = true
				break
			}
		}
		if !found {
			delete(uniqueTypes, tp)
		}
	}
}

func main() {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal("err: ", err)
	}

	entries := []*FFIEntry{}
	err = json.Unmarshal([]byte(ffi), &entries)
	if err != nil {
		log.Fatal("err: ", err)
	}

	// Init all types and functions from SDL3 quick reference
	AllTypesFromAPIRef()

	// Filter and sanitize sdl entries
	n := 0
	for _, e := range entries {
		if !strings.HasPrefix(e.Location, "/usr/include/SDL3/") {
			continue
		}
		// Trim SDL prefixes
		if strings.HasPrefix(e.Name, "SDL_") {
			e.symbolSDLPrefix = true
		}
		trimSDLPrefix(e)
		var allowlisted bool
		if e.Tag == "function" {
			if _, allowlisted = allowlistedFunctions["SDL_"+e.Name]; !allowlisted {
				if _, ok := ignoredFunctions["SDL_"+e.Name]; ok {
					continue
				}
				// skip lower case functions
				if e.Name[0] >= 'a' && e.Name[0] <= 'z' {
					continue
				}
			}

		}
		// Skip some headers
		if !allowlisted {
			base, _, _ := strings.Cut(filepath.Base(e.Location), ":")
			if _, ok := ignoredHeaders[base]; ok {
				continue
			}
		}

		entries[n] = e
		n++
	}
	entries = entries[:n]

	// Register used types
	var regUsedTypes = func(e *FFIEntry) bool {
		var registration bool
		for _, f := range e.Fields {
			// Remove pointer or array potential prefix
			t := strings.ReplaceAll(extractType(f.Type), "*", "")
			if idx := strings.Index(t, "]"); idx != -1 {
				t = t[idx+1:]
			}
			if _, ok := uniqueTypes["SDL_"+t]; !ok {
				uniqueTypes["SDL_"+t] = struct{}{}
				registration = true
			}
		}
		return registration
	}
	var done bool
	for !done {
		done = true
		for _, e := range entries {
			_, ok := uniqueTypes["SDL_"+e.Name]
			if !ok {
				_, ok = baseTypes["SDL_"+e.Name]
			}
			if ok {
				switch e.Tag {
				case "struct", "union":
					if registration := regUsedTypes(e); registration {
						done = false
					}
				case "typedef":
					if _, ok := uniqueTypes["SDL_"+e.Tag]; !ok {
						t := strings.ReplaceAll(extractType(e.Type), "*", "")
						if idx := strings.Index(t, "]"); idx != -1 {
							t = t[idx+1:]
						}
						if _, ok := uniqueTypes["SDL_"+t]; !ok {
							uniqueTypes["SDL_"+t] = struct{}{}
							done = false
						}
					}
				}
			}
		}
	}

	fmt.Println("count entries:", len(entries))

	found := 0
	// Functions
	apifunc := map[string]struct{}{}
	f := jen.NewFile("sdl")
	f.Comment(genComment)
	f.Var().DefsFunc(func(g *jen.Group) {
		g.Comment("//puregogen:library path:windows=sdl.dll path:unix=sdl.so alias=sdl")
		for _, e := range entries {
			if e.Tag != "function" || e.Inline {
				continue
			}
			if ref, ok := uniqueAPIFunctions["SDL_"+e.Name]; ok {
				found++
				apifunc[e.Name] = struct{}{}
				// Only add once
				fn := jen.Id("i" + e.Name).Func()
				fn.ParamsFunc(func(h *jen.Group) {
					for _, ee := range e.Parameters {
						h.Add(
							jen.Id(sanitizeArgName(ee.Name)).Id(extractType(ee.Type)),
						)
					}
				})
				if e.ReturnType != nil && e.ReturnType.Tag != ":void" {
					if _, ok := sdlFreeFunctions["SDL_"+e.Name]; ok {
						fn.Uintptr()
					} else {
						fn.Id(extractType(e.ReturnType))
					}
				}
				if e.symbolSDLPrefix {
					g.Add(jen.Comment(
						"//puregogen:function symbol=SDL_" + e.Name,
					))
				}
				g.Add(jen.Comment(
					"// " + ref.Description,
				))
				if _, ok := sdlFreeFunctions["SDL_"+e.Name]; ok {
					g.Add(jen.Comment(
						"// SDL_free() must be called on the returned pointer.",
					))
				}
				g.Add(fn.Line())
			}
		}
	})
	fmt.Println("count api functions:", len(uniqueAPIFunctions), len(apifunc))
	os.WriteFile(filepath.Join(dir, "sdl_functions.gen.go"), []byte(f.GoString()), 0666)

	// Enums
	f = jen.NewFile("sdl")
	f.Comment(genComment)
	for _, e := range entries {
		if e.Tag != "enum" {
			continue
		}
		if _, ok := uniqueTypes["SDL_"+e.Name]; !ok {
			continue
		}
		f.Type().Id(e.Name).Uint32()
		f.Const().DefsFunc(func(g *jen.Group) {
			for _, ee := range e.Fields {
				g.Add(
					jen.Id(ee.Name).Id(e.Name).Op("=").Lit(ee.Value),
				)
			}
		})
	}
	os.WriteFile(filepath.Join(dir, "sdl_enums.gen.go"), []byte(f.GoString()), 0666)

	// Structs
	f = jen.NewFile("sdl")
	f.Comment(genComment)
	for _, e := range entries {
		if e.Tag != "struct" {
			continue
		}
		if _, ok := ignoredTypes[e.Name]; ok {
			continue
		}
		if _, ok := uniqueTypes["SDL_"+e.Name]; !ok {
			continue
		}
		f.Type().Id(e.Name).StructFunc(func(g *jen.Group) {
			for _, ee := range e.Fields {
				g.Add(
					jen.Id(sanitizeVarName(ee.Name)).Id(extractType(ee.Type)),
				)
			}
		}).Line()
	}
	os.WriteFile(filepath.Join(dir, "sdl_structs.gen.go"), []byte(f.GoString()), 0666)

	// Types
	f = jen.NewFile("sdl")
	f.Comment(genComment)
	f.Type().DefsFunc(func(g *jen.Group) {
		for _, e := range entries {
			switch {
			case e.Tag != "typedef",
				e.Type.Tag == ":struct", e.Type.Tag == "struct",
				e.Type.Tag == ":enum",
				e.Type.Tag == ":union", e.Type.Tag == "union",
				e.Type.Tag == ":function-pointer":
				continue
			}
			if _, ok := uniqueTypes["SDL_"+e.Name]; !ok {
				continue
			}
			if _, handled := typesConversions[e.Name]; handled {
				continue
			}
			typ := extractType(e.Type)
			if e.Name == typ {
				continue
			}
			g.Id(e.Name).Id(typ)
		}
	})
	os.WriteFile(filepath.Join(dir, "sdl_types.gen.go"), []byte(f.GoString()), 0666)
}
